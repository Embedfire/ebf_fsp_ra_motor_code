#include "hal_data.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

#include "led/bsp_led.h"
#include "debug_uart/bsp_debug_uart.h"
#include "motor_control/bsp_motor_control.h"
#include "gpt/bsp_gpt_timing.h"
#include "encoder/bsp_encoder.h"

void Process_Motor_Command(void);  // 处理电机命令的函数声明

extern volatile char Order;  // 外部变量 Order 的声明，表示命令字符
extern _Bool motor_dir;

uint32_t Hz = 6400;

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */

	LED_Init(); // LED 初始化
	Debug_UART9_Init();//调试串口初始化
	
	Motor_Control_Init();	   //初始化电机定时器
	
    MOTOR_PRINT("这是一个步进电机编码器测速示例\r\n");
    MOTOR_PRINT("打开串口助手发送以下指令，可控制电机运行状态：\r\n");
    MOTOR_PRINT("初始速度应为 1转/秒，改变速度观察是否正确\r\n");
    MOTOR_PRINT("S----------------电机开始旋转\r\n");
    MOTOR_PRINT("P----------------电机停止旋转\r\n");
    MOTOR_PRINT("U----------------电机加速（+0.25转/秒）（PWM频率+1600Hz）\r\n");
    MOTOR_PRINT("D----------------电机减速（-0.25转/秒）（PWM频率-1600Hz）\r\n");
    MOTOR_PRINT("R----------------电机反向旋转\r\n");

    /*使能定时器*/
    GPT_Timing_Init();

    //初始化编码器
    initEncoder();

    // 设置定时器周期,初始开环控制速度应该为 1转/秒
    R_GPT_PeriodSet(&step_pwm_ctrl, Hz_Set(Hz));

	while(1)
	{
        //处理用户输入的命令，执行相应的电机控制操作
        Process_Motor_Command();
	}
	
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}


/**
 * @brief 处理用户输入的命令，执行相应的电机控制操作
 *
 * @return 无
 */
void Process_Motor_Command(void)
{
    switch (Order) {
        case 'S':  // 启动电机
            Clear_Order;// 命令被处理后清空
            Motor_Control_Start();  // 调用电机启动函数
            MOTOR_PRINT("电机启动\r\n");
            break;

        case 'P':  // 停止电机
            Clear_Order;// 命令被处理后清空
            Motor_Control_Stop();  // 调用电机停止函数
            MOTOR_PRINT("************电机关闭************\r\n");
            break;

        case 'U':
            Clear_Order;// 命令被处理后清空
            if (Hz >= (PWM_MAX_FREQUENCY - 1600)) {
                Hz = PWM_MAX_FREQUENCY;  // 限制最大频率
                Motor_Control_SetSpeed(Hz); // 设置定时器周期
                MOTOR_PRINT("已到达电机所能承受最大频率，当前频率 = %ld Hz\r\n", Hz);
            } else {
                Hz += QUARTER_SPR;//电机加速（+0.25转/秒）（PWM频率+1600Hz）
                R_GPT_PeriodSet(&step_pwm_ctrl, Hz_Set(Hz)); // 设置定时器周期
                MOTOR_PRINT("电机加速，新的频率 = %ld Hz\r\n", Hz);
            }
            break;

        case 'D':
            Clear_Order;// 命令被处理后清空
            if (Hz <= PWM_MIN_FREQUENCY) {
                Hz = PWM_MIN_FREQUENCY;  // 限制最小频率
                Motor_Control_SetSpeed(Hz); // 设置定时器周期
                MOTOR_PRINT("已到达程序最小频率，当前频率 = %ld Hz\r\n", Hz);
            } else {
                Hz -= QUARTER_SPR;//电机减速（-0.25转/秒）（PWM频率+1600Hz）
                R_GPT_PeriodSet(&step_pwm_ctrl, Hz_Set(Hz)); // 设置定时器周期
                MOTOR_PRINT("电机减速，新的频率 = %ld Hz\r\n", Hz);
            }
            break;

        case 'R':  // 反转电机旋转方向
            Clear_Order;// 命令被处理后清空
            Motor_Control_Reverse();  // 调用电机方向反转函数
            if (motor_dir == true) {
                MOTOR_PRINT("电机方向翻转，当前旋转方向：正向\n");
            } else {
                MOTOR_PRINT("电机方向翻转，当前旋转方向：反向\n");
            }
            break;

        default:  // 无效命令
            Clear_Order;// 命令被处理后清空
            break;
    }
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart (bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
